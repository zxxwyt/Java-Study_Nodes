# 多表查询(基础)
这是MySQL比较难学的部分，接下来我会带着大家通过直观的学习
接下来我们通过黑马程序员的MySQL教程中的实例来学习
：https://www.bilibili.com/video/BV1Kr4y1i7ru

## 📘 目录
1. [我们要用到的表格](#我们要用到的表格)
2. [多表查询的本质](#多表查询的本质)
3. [内连接](#内连接)
4. [外连接](#外连接)
5. [自连接](#自连接)
6. [联合查询（UNION）](#联合查询union)
7. [子查询](#子查询)
   - [① 标量子查询](#标量子查询)
   - [② 列子查询](#列子查询)
   - [③ 行子查询](#行子查询)
   - [④ 表子查询](#表子查询)
8. [总结](#总结)

---



 ## 我们要用到的表格
 ### 员工表：emp
| id | name   | age | job           | salary | entrydate   | managerid | dept_id |
|----|--------|-----|----------------|---------|--------------|------------|----------|
| 1  | 金庸   | 66  | 总裁          | 20000  | 2000-01-01   | NULL       | 5        |
| 2  | 张无忌 | 20  | 项目经理      | 12500  | 2005-12-05   | 1          | 1        |
| 3  | 杨逍   | 33  | 开发          | 8400   | 2000-11-03   | 2          | 1        |
| 4  | 韦一笑 | 48  | 开发          | 11000  | 2002-02-05   | 2          | 1        |
| 5  | 常遇春 | 43  | 开发          | 10500  | 2004-09-07   | 3          | 1        |
| 6  | 小昭   | 19  | 程序员鼓励师  | 6600   | 2004-10-12   | 2          | 1        |
| 7  | 灭绝   | 60  | 财务总监      | 8500   | 2002-09-12   | 1          | 3        |
| 8  | 周芷若 | 19  | 会计          | 48000  | 2006-06-02   | 7          | 3        |
| 9  | 丁敏君 | 23  | 出纳          | 5250   | 2009-05-13   | 7          | 3        |
| 10 | 赵敏   | 20  | 市场部总监    | 12500  | 2004-10-12   | 1          | 2        |
| 11 | 鹿杖客 | 56  | 职员          | 3750   | 2006-10-03   | 10         | 2        |
| 12 | 鹤笔翁 | 19  | 职员          | 3750   | 2007-05-09   | 10         | 2        |
| 13 | 方东白 | 19  | 职员          | 5500   | 2009-02-12   | 10         | 2        |
| 14 | 张三丰 | 88  | 销售总监      | 14000  | 2004-10-12   | 1          | 4        |
| 15 | 俞莲舟 | 38  | 销售          | 4600   | 2004-10-12   | 14         | 4        |
| 16 | 宋远桥 | 40  | 销售          | 4600   | 2004-10-12   | 14         | 4        |
| 17 | 陈友谅 | 42  | NULL           | 2000   | 2011-10-12   | 1          | NULL     |

### 部门表 dept:
| id | name  |
|----|--------|
| 1  | 研发部 |
| 2  | 市场部 |
| 3  | 财务部 |
| 4  | 行政部 |
| 5  | 运营部 |

### 薪资等级表salgrade
| grade | losal | hisal |
|--------|--------|--------|
| 1 | 0 | 3000 |
| 2 | 3001 | 5000 |
| 3 | 5001 | 8000 |
| 4 | 8001 | 10000 |
| 5 | 10001 | 15000 |
| 6 | 15001 | 20000 |
| 7 | 20001 | 25000 |
| 8 | 25001 | 30000 |



## 多表查询的本质
简单来说就是**在多张表的笛卡尔积基础上，通过连接条件（通常是主键与外键的关联）筛选出满足条件的元组，并选取所需的列信息。**
在关系型数据库（如 MySQL）中，每一张表都可以看成一个集合，那么多张表联系在一起就是一个笛卡尔积，如果有两张表你去执行
```sql
select * from emp,dept ;
```
根据上面的表格你会发现会查询出来17(emp的元组个数)*5(部门的元组个数之积)而这么多元组满足笛卡尔积的公式接下来我引用的集合概念并不是两张表的单独部分的关系而是他们笛卡尔积的关系，接下来我会详尽的展开讲述具体的分类

## 内连接
本质：**查询a表和b表组合的笛卡尔积当中交集中的部分数据**  
那么首先列出基本的MySQL代码：
```sql
-- 隐式内连接(基本语法)
SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件

-- 显示内连接
SELECT 字段列表 FROM 表1 RIGHT[OUTER]JOIN 表2 ON 条件
```

假如我有一个需求：.查询每一个员工的姓名，及其关联的部门的名称，这个时候注意到部门名称和姓名在不同的表格当中，而唯一关联这两个表的是emp表里面的dept_id和部门表里面的id。也就是说通过这个条件我们可以关联这两张表                
于是我们可以通过显示内连接的SQL语句或者隐式内连接的SQL语句来实现**相同的功效**
```sql
-- 1.查询每一个员工的姓名，及其关联的部门的名称（隐式内连接）
-- 表结构：emp,dept
-- 链接条件 emp.dept_name=dept.dept_name
select emp.name,dept.name from emp,dept where emp.dept_id=dept.id;
-- 或者显示内连接
select e.name,d.name from emp e inner join dept d on e.dept_id=d.id;
```
于是我们就能得到这样一张查询的结果的表：
| e.name | d.name |
|--------|--------|
| 张无忌 | 研发部 |
| 杨逍   | 研发部 |
| 韦一笑 | 研发部 |
| 常遇春 | 研发部 |
| 小昭   | 研发部 |
| 赵敏   | 市场部 |
| 鹿杖客 | 市场部 |
| 鹤笔翁 | 市场部 |
| 方东白 | 市场部 |
| 灭绝   | 财务部 |
| 周芷若 | 财务部 |
| 丁敏君 | 财务部 |
| 张三丰 | 销售部 |
| 俞莲舟 | 销售部 |
| 宋远桥 | 销售部 |
| 金庸   | 总经办 |

我们可以发现通过内连接的关键语句**dept_id=d.id**将两张表组成的笛卡尔积的结果按照合理对应的方式通过一张表呈现出来。
这也说明这个内连接本质上就是**在两张表的笛卡尔积中，筛选出满足连接条件的那部分（也就是两表的“匹配部分或者说交集部分）**
## 外连接
讲解完了内连接接下来我们继续讲解外连接，外连接说白了就是**在内连接的基础上，再把一边没匹配到的数据也保留下来** “没匹配到的保留下来”这是内连接与外连接最本质的区别。举个例子：我们可以看出到表格里面有个人很特殊
| id | name   | age | job   | salary | entrydate  | managerid | dept_id |
|----|--------|-----|-------|---------|-------------|-----------|---------|
| 17 | 陈友谅 | 42  | <null> | 2000   | 2011-10-12 | 1         | <null>  |

他的dept_id是null也就是不存在，如果使用内连接在**on后面的限制条件dept_id=d.id会把不满足的元组（也就是那一列直接舍去）** 但是在外连接中 **没有连接的部分会保留前提是选择对应的保留的表**  外连接的SQL语句是：                       
```sql
-- 1.左外连接
SELECT 字段列表 FROM 表1 LEFT[OUTER] JOIN 表2 ON 条件 …;
-- 2.右外连接
select e.*,d.name from emp e right join dept d on e.dept_id=d.id;
```
是的外连接有两种一种是左外连接，一种是右外连接，通过观察我们发现**不论是使用 LEFT JOIN 还是 RIGHT JOIN，
在 FROM 后面的表始终是左表，JOIN 后面的表始终是右表。
因此，RIGHT JOIN 的效果可以通过 交换两张表的位置 并使用 LEFT JOIN 来实现。这也是为什么在实际开发中，左外连接（LEFT JOIN）更常用，因为语义更直观，便于理解和维护。** 接下来我们通过实例进行讲解。 **记住不论外连接还是内连接都需要连接条件（也就是on后面的部分）**

```sql
-- 1.查询emp的所有数据和对应的部门信息（左外连接）
-- 表结构 emp,dept;
-- 连接条件：emp.dep_name=dept.id;
select e.*,d.name from emp e left join dept d on e.dept_id=d.id;
-- 2.查询dept表的所有数据。和对应的员工信息、（右外连接）
select e.*,d.name from emp e right join dept d on e.dept_id=d.id;

```
第一个查询的结果是一张这样的表格：
| id | name   | age | job         | salary | entrydate   | managerid | dept_id | dept_name |
|----|--------|-----|--------------|---------|-------------|-----------|----------|------------|
| 1  | 金庸   | 66  | 总裁         | 20000   | 2000-01-01  | <null>    | 5        | 总经办     |
| 2  | 张无忌 | 20  | 项目经理     | 12500   | 2005-12-05  | 1         | 1        | 研发部     |
| 3  | 杨逍   | 33  | 开发         | 8400    | 2000-11-03  | 2         | 1        | 研发部     |
| 4  | 韦一笑 | 48  | 开发         | 11000   | 2002-02-05  | 2         | 1        | 研发部     |
| 5  | 常遇春 | 43  | 开发         | 10500   | 2004-09-07  | 3         | 1        | 研发部     |
| 6  | 小昭   | 19  | 程序员鼓励师 | 6600    | 2004-10-12  | 2         | 1        | 研发部     |
| 7  | 灭绝   | 60  | 财务总监     | 8500    | 2002-09-12  | 1         | 3        | 财务部     |
| 8  | 周芷若 | 19  | 会计         | 48000   | 2006-06-02  | 7         | 3        | 财务部     |
| 9  | 丁敏君 | 23  | 出纳         | 5250    | 2009-05-13  | 7         | 3        | 财务部     |
| 10 | 赵敏   | 20  | 市场部总监   | 12500   | 2004-10-12  | 1         | 2        | 市场部     |
| 11 | 鹿杖客 | 56  | 职员         | 3750    | 2006-10-03  | 10        | 2        | 市场部     |
| 12 | 鹤笔翁 | 19  | 职员         | 3750    | 2007-05-09  | 10        | 2        | 市场部     |
| 13 | 方东白 | 19  | 职员         | 5500    | 2009-02-12  | 10        | 2        | 市场部     |
| 14 | 张三丰 | 88  | 销售总监     | 14000   | 2004-10-12  | 1         | 4        | 销售部     |
| 15 | 俞莲舟 | 38  | 销售         | 4600    | 2004-10-12  | 14        | 4        | 销售部     |
| 16 | 宋远桥 | 40  | 销售         | 4600    | 2004-10-12  | 14        | 4        | 销售部     |
| 17 | 陈友谅 | 42  | <null>       | 2000    | 2011-10-12  | 1         | <null>   | <null>     |

我们发现第17条数据 陈友谅是没有部门对应的但是却还是保留了，所以而且是保留了left表也就是emp表的所有元组的内容，而且通过观察我们还可以发现：即使左表的内容在右表找不到但是还是会默认用null填充这说明外连接本质就是**在保留某一张表原有数据的基础上，尝试与另一张表进行匹配连接；若无法匹配，则用 NULL 填充。** 所以我们还可以看看第二个执行语句（这次我们用right join）

```sql
-- 2.查询dept表的所有数据。和对应的员工信息、（右外连接）
select e.*,d.name from emp e right join dept d on e.dept_id=d.id;
```
| id | name   | age | job         | salary | entrydate   | managerid | dept_id | dept_name |
|----|--------|-----|--------------|---------|-------------|-----------|----------|------------|
| 2  | 张无忌 | 20  | 项目经理     | 12500   | 2005-12-05  | 1         | 1        | 研发部     |
| 3  | 杨逍   | 33  | 开发         | 8400    | 2000-11-03  | 2         | 1        | 研发部     |
| 4  | 韦一笑 | 48  | 开发         | 11000   | 2002-02-05  | 2         | 1        | 研发部     |
| 5  | 常遇春 | 43  | 开发         | 10500   | 2004-09-07  | 3         | 1        | 研发部     |
| 6  | 小昭   | 19  | 程序员鼓励师 | 6600    | 2004-10-12  | 2         | 1        | 研发部     |
| 10 | 赵敏   | 20  | 市场部总监   | 12500   | 2004-10-12  | 1         | 2        | 市场部     |
| 11 | 鹿杖客 | 56  | 职员         | 3750    | 2006-10-03  | 10        | 2        | 市场部     |
| 12 | 鹤笔翁 | 19  | 职员         | 3750    | 2007-05-09  | 10        | 2        | 市场部     |
| 13 | 方东白 | 19  | 职员         | 5500    | 2009-02-12  | 10        | 2        | 市场部     |
| 7  | 灭绝   | 60  | 财务总监     | 8500    | 2002-09-12  | 1         | 3        | 财务部     |
| 8  | 周芷若 | 19  | 会计         | 48000   | 2006-06-02  | 7         | 3        | 财务部     |
| 9  | 丁敏君 | 23  | 出纳         | 5250    | 2009-05-13  | 7         | 3        | 财务部     |
| 14 | 张三丰 | 88  | 销售总监     | 14000   | 2004-10-12  | 1         | 4        | 销售部     |
| 15 | 俞莲舟 | 38  | 销售         | 4600    | 2004-10-12  | 14        | 4        | 销售部     |
| 16 | 宋远桥 | 40  | 销售         | 4600    | 2004-10-12  | 14        | 4        | 销售部     |
| 1  | 金庸   | 66  | 总裁         | 20000   | 2000-01-01  | <null>    | 5        | 总经办     |
| <null> | <null> | <null> | <null> | <null> | <null> | <null> | <null> | 人事部 |

我们发现结论和刚刚的一样。这里我就不多赘述大家可以通过表格感受一下。                        
总结：外连接用于在两张表连接时保留一方的全部数据，即使另一方无匹配记录也会以NULL填充。根据保留的表不同，分为左外连接和右外连接。左外连接保留左表全部记录，右外连接保留右表全部记录。其本质是在保留一张表完整数据的基础上，将另一张表中能匹配的部分补充进来，未匹配的以NULL表示。实际开发中通常使用LEFT JOIN，因为RIGHT JOIN可通过交换两表实现相同效果。

## 自连接
自连接说白了就是自己和自己连接，相当于自己和自己进行外连接，所以这个东西的理解方式完全可以参考外连接。那么连接的条件是什么呢我们先观察一下emp这张表格
| id | name  | age | job     | salary | entrydate  | managerid | dept_id |
|----|--------|-----|---------|---------|-------------|-----------|---------|
| 1  | 张三   | 25  | 技术员  | 8000    | 2020-01-10  | 2         | 10      |
| 2  | 李四   | 30  | 经理    | 15000   | 2018-03-05  | NULL      | 10      |
| 3  | 王五   | 28  | 会计    | 9000    | 2021-05-20  | 2         | 20      |
| 4  | 赵六   | 35  | 部门主管 | 12000   | 2017-09-15  | NULL      | 20      |

我们发现如果想要关联两张表如果只是自己等于自己比如设第一个表为A第二个为B 如果条件只是A.id=B.id那么其实没有什么意义因为还是跟没有加限制条件一样我们可以通过结论得出来
```sql
-- 无效的限制条件：A.id=B.id
select a.name ,b.name  from emp a,emp b where a.id=b.id;
```
得到的表：
| a.name | b.name |
|--------|--------|
| 金庸 | 金庸 |
| 张无忌 | 张无忌 |
| 杨逍 | 杨逍 |
| 韦一笑 | 韦一笑 |
| 常遇春 | 常遇春 |
| 小昭 | 小昭 |
| 灭绝 | 灭绝 |
| 周芷若 | 周芷若 |
| 丁敏君 | 丁敏君 |
| 赵敏 | 赵敏 |
| 鹿杖客 | 鹿杖客 |
| 鹤笔翁 | 鹤笔翁 |
| 方东白 | 方东白 |
| 张三丰 | 张三丰 |
| 俞莲舟 | 俞莲舟 |
| 宋远桥 | 宋远桥 |
| 陈友谅 | 陈友谅 |
显然没有意义。那么什么有意义呢，我们观察到id和manageid有天生的自然关系他们的属性属于同一个类型都是id都指向一个特定的人**如果限制条件加上a.managerid=b.id我们就可以找出a中的员工数据和及其领导的关系表**
```sql
1.查询员工 及其所属领导的名字
-- 表结构：emp
select a.name ,b.name  from emp a,emp b where a.managerid=b.id;
```
通过这个查询语句就可以找到员工对应的主管信息
| a.name | b.name |
|-----|-----|
| 张无忌 | 金庸 |
| 杨逍 | 张无忌 |
| 韦一笑 | 张无忌 |
| 常遇春 | 杨逍 |
| 小昭 | 张无忌 |
| 灭绝 | 金庸 |
| 周芷若 | 灭绝 |
| 丁敏君 | 灭绝 |
| 赵敏 | 金庸 |
| 鹿杖客 | 赵敏 |
| 鹤笔翁 | 赵敏 |
| 方东白 | 赵敏 |
| 张三丰 | 金庸 |
| 俞莲舟 | 张三丰 |
| 宋远桥 | 张三丰 |
| 陈友谅 | 金庸 |
既然有外连接的属性，自然也支持左右的自连接
```sql
-- 左自连接
SELECT 字段列表 FROM 表A 别名A LEFT JOIN 表A 别名B ON 连接条件...;
-- 右自连接
SELECT 字段列表 FROM 表A 别名A RIGHT JOIN 表A 别名B ON 连接条件...;
-- 内自连接
SELECT 字段列表 FROM 表A 别名A INNER JOIN 表A 别名B ON 连接条件...;
```
我们可以通过下面的实例了解一下：
```sql
-- 2.查询所有员工emp及其领导的名字emp，如果员工没有领导，也需要查询出来
-- 表结构：emp a，emp b
select a.name '员工',b.name '领导' from emp a left join emp b on a.managerid=b.id;

```
这样就可以保证左表完整保证连接的完整性这一点可以看我的另一篇文章[外连接](#外连接)**里面有详细讲解**。
通过上面的语句可以得到下面的表格：
| 员工 | 领导 |
|------|------|
| 金庸 | NULL |
| 张无忌 | 金庸 |
| 杨逍 | 张无忌 |
| 韦一笑 | 张无忌 |
| 常遇春 | 杨逍 |
| 小昭 | 张无忌 |
| 灭绝 | 金庸 |
| 周芷若 | 灭绝 |
| 丁敏君 | 灭绝 |
| 赵敏 | 金庸 |
| 鹿杖客 | 赵敏 |
| 鹤笔翁 | 赵敏 |
| 方东白 | 赵敏 |
| 张三丰 | 金庸 |
| 俞莲舟 | 张三丰 |
| 宋远桥 | 张三丰 |
| 陈友谅 | 金庸 |

总结：内连接的本质就是**A表里这一行，能不能在 B 表里找到一个符合条件的内容比如这里的id和manageid就是在两张表之间“找对的上号的记录能对上的留下，不能对上的就不要**
## 联合查询（UNION）
接下来我们讲一下联合查询，其本质就是**就是把多次查询的结果合并起来，形成新的结果集一定要记清楚union联合是或的关系不是与的关系**
！！！还需要注意的点**联合查询的多张表格必须保障里面的元组的属性的一致不能一个有id一个没有id。在联合查询中，每个 SELECT 语句返回的列数和对应列的数据类型必须一致。否则无法纵向合并。**
先给出基本语法：
```sql
-- 1.联合查询 UNION
SELECT 字段列表 FROM 表A [WHERE 条件...]
UNION
SELECT 字段列表 FROM 表B [WHERE 条件...];
-- 2.联合查询（保留重复行）UNION ALL
SELECT 字段列表 FROM 表A [WHERE 条件...]
UNION ALL
SELECT 字段列表 FROM 表B [WHERE 条件...];

```
如何理解呢比如我们有两张表（我们通过查询语句得出的表格）：

```sql
-- 1.将薪资低于5000的员工全部查询出来
select * from emp where salary<5000 ;
-- 2.将年龄大于50岁的员工全部查询出来
select * from emp where age>50 ;
```
第一个表格：
| id | name | age | job | salary | entrydate | managerid | dept_id |
|----|------|-----|------|---------|------------|------------|----------|
| 11 | 鹿杖客 | 56 | 职员 | 3750 | 2006-10-03 | 10 | 2 |
| 12 | 鹤笔翁 | 19 | 职员 | 3750 | 2007-05-09 | 10 | 2 |
| 15 | 俞莲舟 | 38 | 销售 | 4600 | 2004-10-12 | 14 | 4 |
| 16 | 宋远桥 | 40 | 销售 | 4600 | 2004-10-12 | 14 | 4 |
| 17 | 陈友谅 | 42 | NULL | 2000 | 2011-10-12 | 1 | NULL |

第二个表格：
| id | name | age | job | salary | entrydate | managerid | dept_id |
|----|------|-----|------|---------|------------|------------|----------|
| 1  | 金庸 | 66 | 总裁 | 20000 | 2000-01-01 | NULL | 5 |
| 7  | 灭绝 | 60 | 财务总监 | 8500 | 2002-09-12 | 1 | 3 |
| 11 | 鹿杖客 | 56 | 职员 | 3750 | 2006-10-03 | 10 | 2 |
| 14 | 张三丰 | 88 | 销售总监 | 14000 | 2004-10-12 | 1 | 4 |

这两个表去重结合：
```sql
-- 删掉all可以去重
select * from emp where salary<5000
union
select * from emp where age>50;
```
得到这个表：
| id | name | age | job | salary | entrydate | managerid | dept_id |
|----|------|-----|------|---------|------------|------------|----------|
| 11 | 鹿杖客 | 56 | 职员 | 3750 | 2006-10-03 | 10 | 2 |
| 12 | 鹤笔翁 | 19 | 职员 | 3750 | 2007-05-09 | 10 | 2 |
| 15 | 俞莲舟 | 38 | 销售 | 4600 | 2004-10-12 | 14 | 4 |
| 16 | 宋远桥 | 40 | 销售 | 4600 | 2004-10-12 | 14 | 4 |
| 17 | 陈友谅 | 42 | NULL | 2000 | 2011-10-12 | 1 | NULL |
| 1  | 金庸 | 66 | 总裁 | 20000 | 2000-01-01 | NULL | 5 |
| 7  | 灭绝 | 60 | 财务总监 | 8500 | 2002-09-12 | 1 | 3 |
| 14 | 张三丰 | 88 | 销售总监 | 14000 | 2004-10-12 | 1 | 4 |

这个就是union的效果
总结：**联合查询的本质就是把多条 SELECT 查询的结果“竖着拼” 到一起展示的一种方式或者说几张结构一样的表，把查出来的数据一层层往下叠。**
## 
